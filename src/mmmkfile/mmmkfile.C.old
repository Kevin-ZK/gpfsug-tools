/* 
 * Name: mmmkfile.c
 * Description: Preallocates a file of k/kb/MB/GB/TB on a GPFS filesystem
 *              Imitates the behaviour of the standard UNIX mkfile utility
 *              Majority of code was shamelessly cribbed from IBMs preallocate.c example on:
 *              https://publib.boulder.ibm.com/infocenter/clresctr/vxrx/index.jsp?topic=%2Fcom.ibm.cluster.gpfs.v3r4.gpfs300.doc%2Fbl1adm_preallc.html
 * 
 * Author: Jez Tucker
 * Date: 24 Feb 2012
 * Version : 0.1
 *
 */

#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <gpfs.h>
#include <stdlib.h>
#include <pthread.h>

int rc;
int opt, optind;
int numStreams = 1;  // single threaded by default
int chunkSize = 4*1024*1024; // 4MB block sizes for writing
int fileHandle = -1;
char* fileNameP = "";
typedef long long offset_t;
offset_t startOffset = 0;
offset_t bytesToAllocate = 0;

void
print_help() 
{
    fprintf(stdout, "help file\n");

/*    b // default
    k
    m
    g
    t
    
    n 'Create an empty filename. The size is noted, but  disk
           blocks  are  not  allocated  until  data is written to
           them. Files created with this option cannot be swapped
           over local UFS mounts.'
    v 'Verbose.  Report the names and sizes of created files'

*/

}

void
*zeroFill(void *threadid)
{
    long tid;
    tid = (long)threadid;
    printf("zerofilling thread #%ld\n", tid);
    pthread_exit(NULL);
}

int 
main(int argc, char *argv[])
{
	int count =0;
      for (count = 0; count < argc; count++)
	{
	  printf("argv[%d] = %s\n", count, argv[count]);
	}


    // Check the args
    while ((opt = getopt(argc, argv, "b:k:m:g:t:s:c:nvh")) != EOF) 
    {
	switch (opt) {
	    case 'h' :
		print_help();
		exit(EXIT_FAILURE);
		break;
	    case 't' :
		 fprintf(stdout, "teee");
		if (optarg) {
		    bytesToAllocate = atoi(optarg)*1024*1024*1024*1024;
                } else {
			fprintf(stdout, "no arg");
		}
		break;
	    case 'g' : 
		bytesToAllocate = atoi(optarg)*1024*1024*1024;
		break;
	    case 'm' :
		bytesToAllocate = atoi(optarg)*1024*1024;
		break;
	    case 'k' :
		bytesToAllocate = atoi(optarg)*1024;
		break;
            case 's':
                numStreams = atoi(optarg);
		break;
            case 'c' :
                chunkSize = atoi(optarg);
                break;
	    case 'b': // fall through to default
	    default:
		bytesToAllocate = atoi(optarg);
		break;
	}
    }

   fprintf(stdout, "hello");

    // Check a filename was passed
    if (optind >= argc)
    {
	fprintf(stderr, "Expected filename after options\n");
	exit(EXIT_FAILURE);
    } 
    else
    {
	fileNameP = argv[optind];	
    }

    /* Open the file handle */
    fileHandle = open(fileNameP, O_RDWR|O_CREAT, 0644);
    if (fileHandle < 0)
    {
        perror(fileNameP);
        exit(1);
    }

    rc = gpfs_prealloc(fileHandle, startOffset, bytesToAllocate); 
    if (rc < 0)
    {
        fprintf(stderr, "Error %d preallocation at %lld for %lld in %s\n",
             errno, startOffset, bytesToAllocate, fileNameP);
        exit(1);
    } 
    
    // create a number of threads to write zeros to the preallocated file (faster)
    long threadCount = 0;
    int trc = 0;

    // calculate num threads required (size / blocks )
    int numReqThreads = 
    // if mantissa then last block needs to be odd sized

    // reset numThreads if necessary

    pthread_t threads[numStreams];
    
    for (threadCount=0; threadCount < numStreams; threadCount++) 
    {
       printf("Creating thread %ld\n", threadCount);
       trc = pthread_create(&threads[threadCount], NULL, zeroFill, chunk, (void *)threadCount);
       if (trc) 
       {
           printf("ERROR: thread rc from pthread_create() is %d\n", trc);
           exit(EXIT_FAILURE);
       }
    }
    


    close(fileHandle);

    // Exit nicely
    exit(EXIT_SUCCESS);
}

// EOF
