#!/bin/bash

# Author: Jez Tucker
# Email:  jez.tucker@gpfsug.org
#
VERSION="0.1"

# Settings which affect TSM performance
NUM_MIGRATORS=1
NUM_FILES_PER_MIG=5000

# GPFS Policy settings
POLROOT=/mnt/gpfs/resources/policies/by_stgpool
POLOPT="-m $NUM_MIGRATORS -B $NUM_FILES_PER_MIG -g /mnt/gpfs/policytmp -s /mnt/gpfs/policytmp -N tsm01"
LOGDIR=/var/log/gpfs/policies
LOCKDIR=/mnt/gpfs/policytmp
EMAILDEST='foo@bar.com'

EVENTTYPE=$1
FSNAME=$2
STGPOOL=$3

# Log that we have received the alert
echo "    Callback event: $EVENTTYPE, fs:$FSNAME stgpool:$STGPOOL"

# Check for valid events that this script can handle
if [ $EVENTTYPE != 'lowDiskSpace' ] && [ $EVENTTYPE != 'noDiskSpace' ]; then
  echo "Event type: $EVENTTYPE not handled. Exiting."
  exit 1;
fi

# If there's no disk space, send an urgent email
if [ $EVENTTYPE = 'noDiskSpace' ]; then
  echo "$STGPOOL noDiskSpace" | /bin/mail -s "GPFS Critical Error: $STGPOOL noDiskSpace" $EMAILDEST
fi

# Valid event recognised
if [ -r "$POLROOT/$STGPOOL/${STGPOOL}_hsm.pol" ]; then 

  if [ -f "$POLROOT/$STGPOOL/${STGPOOL}_hsm.pol.isdisabled" ]; then
    echo "       $STGPOOL HSM policy has been manually disabled"; 
    exit 0; 
  fi

  # Check what mode the policy should be running in
  if [ -f "$POLROOT/$STGPOOL/${STGPOOL}_hsm.pol.testmode" ]; then
    RUNMODE="-I test"
  else
    RUNMODE="-I yes"
  fi
  POLOPT="$POLOPT $RUNMODE"

  # Check for a lockdir for this policy
  if [ -d "$LOCKDIR/${STGPOOL}_hsm.lock" ]; then

  #INSTANCES=$(ps -ef | grep  "/usr/lpp/mmfs/bin/mmapplypolicy $FSNAME -P $POLROOT/$STGPOOL/${STGPOOL}_hsm.pol" | grep -v grep | wc -l)

  #if [ $INSTANCES -gt 0 ]; then

	echo "      FS policy already running.  Not starting this instance.";

	# print some useful stats
	if [ -r "$LOCKDIR/${STGPOOL}_hsm.lock/info" ]; then
	
		INFOPID=$(cat $LOCKDIR/${STGPOOL}_hsm.lock/pid)
		INFOSTART=$(cat $LOCKDIR/${STGPOOL}_hsm.lock/started)
		INFONOW=$(date +%s)
		INFOELAPSED=$(expr $INFONOW - $INFOSTART | date +"%Hh:%mm:%Ss")

		echo "          Process ID: $INFOPID    Running time: $INFOELAPSED";

	fi

  else # no policy running, (we think)
    echo "      Processing HSM policy $POLROOT/$STGPOOL/${STGPOOL}_hsm.pol on file system $FSNAME mode: $RUNMODE"

	# Create the directory lock  (directories are atomic, lock files are not)
	mkdir $LOCKDIR/${STGPOOL}_hsm.lock

	# If we couldn't create the directory email an alert and exit
	if [ ! -d "$LOCKDIR/${STGPOOL}_hsm.lock" ]; then
		
		# Generate warning email
		echo "Could not create lockdir $LOCKDIR/${STGPOOL}_hsm.lock.  Failed to start HSM policy." | /bin/mail -s "GPFS Critical Error: Could not create lockdir $LOCKDIR/${STGPOOL}_hsm.lock" $EMAILDEST

		exit 1;
	fi

    # Run the policy
    GPFSCMD="/usr/lpp/mmfs/bin/mmapplypolicy $FSNAME -P $POLROOT/$STGPOOL/${STGPOOL}_hsm.pol $POLOPT > $LOGDIR/${STGPOOL}_hsm.pol.log.$(date +'%Y.%m.%d.%H.%M.%S').$(hostname -s) 2>&1" 

    eval $GPFSCMD

	# Grab the return value from eval - did the process start OK?
    RET=$?
	POLPID=$!  # Process id of mmapplypolicy
	
	# If mmapplypolicy started ok, store the policy process ID in a file in the lockdir, along with the unix time the policy was started
	if [ $RET ]; then 
		echo "$POLPID" > $LOCKDIR/${STGPOOL}_hsm.lock/pid
		echo "$(date +%s)" > $LOCKDIR/${STGPOOL}_hsm.lock/started
	else
		# Remove the lockdir, if it exists
		rm -rf $LOCKDIR/${STGPOOL}_hsm.lock
	fi
  fi

else

  # Log error message in GPFS ras log
  echo "$POLROOT/$STGPOOL/${STGPOOL}_hsm.pol not found."

  # Generate warning email
  echo "$POLROOT/$STGPOOL/${STGPOOL}_hsm.pol not found." | /bin/mail -s "GPFS Critical Error: $STGPOOL migrate script not found" $EMAILDEST

  RET=1
fi

# Remove the lockdir, if it exists
rm -rf $LOCKDIR/${STGPOOL}_hsm.lock

# Check that the lockdir was removed
# If we couldn't create the directory email an alert and exit
if [ -d "$LOCKDIR/${STGPOOL}_hsm.lock" ]; then
  echo "Could not remove lockdir $LOCKDIR/${STGPOOL}_hsm.lock.  Future HSM policies will not start." | /bin/mail -s "GPFS Critical Error: Could not create lockdir $LOCKDIR/${STGPOOL}_hsm.lock" $EMAILDEST
fi 

exit $RET

# EOF
